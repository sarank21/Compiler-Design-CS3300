//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;

//import jdk.nashorn.internal.codegen.SpillObjectCreator;


/*
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */

public class GJDepthFirst<R,A> implements GJVisitor<R,A> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //

	
   public R visit(NodeList n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n, A argu) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n, A argu) {
      if ( n.present() )
         return n.node.accept(this,argu);
      else
         return null;
   }

   public R visit(NodeSequence n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public class temp_info {
      String temp_name;
      int st=-1, end=-1;
      Boolean stack=false, alloc=false;
      String reg, loc;
   }

   public class label_info {
      Integer label_line;
      String new_label;
   }

   public class fun_env {
      String fun_name;
      int stack_pointer;
      Boolean call=false, filled=false;
      int max_arg=0;
      String args;
      HashMap<String, temp_info> temps = new HashMap<>();
      HashMap<String, label_info> labels = new HashMap<>();
   }

   void init_regs()
   {
      for(int i=0 ; i<8 ; i++) {
         regs.put("s"+i, -1);
      }
      for(int i=0 ; i<10 ; i++) {
         regs.put("t"+i, -1);
      }

      // for(int i=0 ; i<4 ; i++) {
      //    regs.put("a"+i, -1);
      // }
      // regs.put("v0", -1);
      // regs.put("v1", -1);
   }

   HashMap<String, fun_env> map = new HashMap<>();
   HashMap<String, Integer> regs = new HashMap<>();
   HashMap<Integer, fun_env> ordered_funs = new HashMap<>();
   Vector<String> arguments = new Vector<String>();
   String curr_fun;
   Boolean first_trav = true;
   int arg_no=0;
   int line_count=0;
   Boolean label = false;
   int cnt=0;
   Boolean args_flag = false;
   Boolean v0_flag = false;
   int label_counter=1;
   Boolean want_int = false;
   Boolean want_temp = false;
   //HashMap<String, Integer> labels = new HashMap<>();

   public R visit(NodeToken n, A argu) { return (R)n.tokenImage; }

   /**
    * f0 -> Label()
    * f1 -> "["
    * f2 -> IntegerLiteral()
    * f3 -> "]"
    * f4 -> StmtExp()
    */
   public R visit(Procedure n, A argu) {
      R _ret=null;
      if(first_trav) {
         curr_fun = (String)n.f0.accept(this, argu);     
         //System.out.println("Adding "+curr_fun); 
         n.f1.accept(this, argu);
         String arg = (String)n.f2.accept(this, argu);    
         int arg_no = Integer.parseInt(arg);
         n.f3.accept(this, argu);
         //System.out.println("Proc incr "+line_count);
         line_count++;
         fun_env curr_env = new fun_env();
         curr_env.args = arg;
         curr_env.fun_name = curr_fun;
         map.put(curr_fun, curr_env);
         ordered_funs.put(cnt, curr_env);
         cnt++;
         init_args(arg_no, curr_env);
         n.f4.accept(this, argu);
         //System.out.println("Function Done");
         //System.out.println(curr_env.temps);
         return _ret;
      }
      else {
         curr_fun = (String)n.f0.accept(this, argu);
         //System.out.println("Curr fun is "+curr_fun);
         if(!map.containsKey(curr_fun)) {System.out.println(curr_fun+" not present"); System.exit(0);}
         fun_env curr_env = map.get(curr_fun);
         if(curr_env.call)
            System.out.println(curr_fun+" ["+curr_env.args+"] ["+curr_env.stack_pointer+"] ["+curr_env.max_arg+"]");
         else
            System.out.println(curr_fun+" ["+curr_env.args+"] ["+curr_env.stack_pointer+"] ["+curr_env.max_arg+"]");
         n.f1.accept(this, argu);
         want_int = true;
         n.f2.accept(this, argu);      
         want_int = false;
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         return _ret;
      }
   }

//
   // User-generated visitor methods below
   //

   /**
    * f0 -> "MAIN"
    * f1 -> StmtList()
    * f2 -> "END"
    * f3 -> ( Procedure() )*
    * f4 -> <EOF>
    */
   public R visit(Goal n, A argu) {
      R _ret=null;
      init_regs();
      fun_env main_env = new fun_env();
      main_env.args = "0";
      curr_fun = "MAIN";
      main_env.fun_name = curr_fun;arguments.clear();
      line_count++;
      map.put(curr_fun, main_env);
      ordered_funs.put(cnt, main_env);
      cnt++;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);    
      line_count++;   
      //System.out.println("MAIN Done");
      //System.out.println(main_env.temps);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);    
      first_trav=false;
      // System.out.println("Order of function");
      // fun_order();
      //System.out.println("Allocating Registers");
      reg_alloc();
      //System.out.println("Second Traverse");
      curr_fun = "MAIN";
      fun_env curr_env = map.get(curr_fun);
      System.out.println(curr_fun+" ["+curr_env.args+"] ["+curr_env.stack_pointer+"] ["+curr_env.max_arg+"]");
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);    
      System.out.println("END");      
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);  
      return _ret;    
   }

   /**
    * f0 -> ( ( Label() )? Stmt() )*
    */
   public R visit(StmtList n, A argu) {
      R _ret=null;
      if(first_trav) {
         label = true;
         n.f0.accept(this, argu);
         label = false;
      }
      else {
         label = true;
         n.f0.accept(this, argu);
         label = false;
      }
      return _ret;
   }

   /**
    * f0 -> NoOpStmt()
    *       | ErrorStmt()
    *       | CJumpStmt()
    *       | JumpStmt()
    *       | HStoreStmt()
    *       | HLoadStmt()
    *       | MoveStmt()
    *       | PrintStmt()
    */
   public R visit(Stmt n, A argu) {
      R _ret=null;  
      if(first_trav) {
         line_count++;  
         Boolean t = label;
         label = false;
         n.f0.accept(this, argu);  
         label = t;  
         //System.out.println("Statement line "+line_count);
      }
      else {
         Boolean t = label;
         label = false;
         n.f0.accept(this, argu);
         label = t;  
      }
      return _ret;
   }

   /**
    * f0 -> "NOOP"
    */
   public R visit(NoOpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      if(!first_trav) {System.out.println("NOOP");}
      return _ret;
   }

   /**
    * f0 -> "ERROR"
    */
   public R visit(ErrorStmt n, A argu) {
      R _ret=null;
      if(first_trav) {
         n.f0.accept(this, argu);
      }
      else {
         n.f0.accept(this, argu);
         System.out.println("ERROR");
      }
      return _ret;
   }

   /**
    * f0 -> "CJUMP"
    * f1 -> Temp()
    * f2 -> Label()
    */
   public R visit(CJumpStmt n, A argu) {
      R _ret=null;
      if(first_trav) {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         String label_name = (String)n.f2.accept(this, argu);
         fun_env t = map.get(curr_fun);
         if(t.labels.containsKey(label_name)) {
            back_edge(t.labels.get(label_name).label_line, line_count);
         }
      }
      else {
         n.f0.accept(this, argu);
         String reg = (String)n.f1.accept(this, argu);
         v0_flag = false;
         String labl = (String)n.f2.accept(this, argu);
         System.out.println("CJUMP "+reg+" "+labl);
      }
      return _ret;
   }

   /**
    * f0 -> "JUMP"
    * f1 -> Label()
    */
   public R visit(JumpStmt n, A argu) {
      R _ret=null;
      if(first_trav) {
         n.f0.accept(this, argu);
         String label_name = (String)n.f1.accept(this, argu);
         fun_env t = map.get(curr_fun);
         if(t.labels.containsKey(label_name)) {
            back_edge(t.labels.get(label_name).label_line, line_count);
         }
      }
      else {
         n.f0.accept(this, argu);
         String label_name = (String)n.f1.accept(this, argu);
         System.out.println("JUMP "+label_name);
      }
      return _ret;
   }

   /**
    * f0 -> "HSTORE"
    * f1 -> Temp()
    * f2 -> IntegerLiteral()
    * f3 -> Temp()
    */
   public R visit(HStoreStmt n, A argu) {
      R _ret=null;
      if(first_trav) {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
      }
      else {
         n.f0.accept(this, argu);
         String reg1 = (String)n.f1.accept(this, argu);
         want_int = true;
         String num = (String)n.f2.accept(this, argu);
         want_int = false;
         String reg2 = (String)n.f3.accept(this, argu);
         v0_flag = false;
         System.out.println("HSTORE "+reg1+" "+num+" "+reg2);
      }
      return _ret;
   }

   /**
    * f0 -> "HLOAD"
    * f1 -> Temp()
    * f2 -> Temp()
    * f3 -> IntegerLiteral()
    */
   public R visit(HLoadStmt n, A argu) {
      R _ret=null;
      if(first_trav) {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
      }
      else {
         n.f0.accept(this, argu);
         want_temp = true;
         String temp_val = (String)n.f1.accept(this, argu);
         want_temp = false;
         String reg2 = (String)n.f2.accept(this, argu);
         v0_flag = false;
         want_int = true;
         String num = (String)n.f3.accept(this, argu);
         want_int = false;
         hload_statement(temp_val, map.get(curr_fun), reg2+" "+num);
      }
      return _ret;
   }

   /**
    * f0 -> "MOVE"
    * f1 -> Temp()
    * f2 -> Exp()
    */
   public R visit(MoveStmt n, A argu) {
      R _ret=null;
      if(first_trav) {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
      }
      else {
         n.f0.accept(this, argu);
         want_temp = true;
         String temp_val = (String)n.f1.accept(this, argu);
         want_temp = false;
         String to_move = (String)n.f2.accept(this, argu);
         fun_env curr_envir = map.get(curr_fun);
         move_statement(temp_val, curr_envir, to_move);
         v0_flag = false;
      }
      return _ret;
   }

   /**
    * f0 -> "PRINT"
    * f1 -> SimpleExp()
    */
   public R visit(PrintStmt n, A argu) {
      R _ret=null;
      if(first_trav) {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
      }
      else {
         n.f0.accept(this, argu);
         String reg = (String)n.f1.accept(this, argu);
         System.out.println("PRINT "+reg);
      }      
      return _ret;
   }

   /**
    * f0 -> Call()
    *       | HAllocate()
    *       | BinOp()
    *       | SimpleExp()
    */
   public R visit(Exp n, A argu) {
      R _ret=null;
      if(first_trav) {
         n.f0.accept(this, argu);
      }
      else  {
         _ret = n.f0.accept(this, argu);
      }
      return _ret;
   }

   /**
    * f0 -> "BEGIN"
    * f1 -> StmtList()
    * f2 -> "RETURN"
    * f3 -> SimpleExp()
    * f4 -> "END"
    */
   public R visit(StmtExp n, A argu) {
      R _ret=null;
      if(first_trav) {
         n.f0.accept(this, argu);
         line_count++;
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         line_count++;
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         line_count++;
      }
      else {
         n.f0.accept(this, argu);
         fun_env tt = map.get(curr_fun);
         int no_args = Integer.parseInt(tt.args);
         callee_store(tt);
         assign_args(no_args, tt);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         String ret_reg = (String)n.f3.accept(this, argu);
         System.out.println("MOVE v0 "+ret_reg);
         callee_load(tt);
         n.f4.accept(this, argu);
         System.out.println("END");
      }
      return _ret;
   }

   /**
    * f0 -> "CALL"
    * f1 -> SimpleExp()
    * f2 -> "("
    * f3 -> ( Temp() )*
    * f4 -> ")"
    */
   public R visit(Call n, A argu) {
      R _ret=null;
      if(first_trav) {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         arg_no=0;
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         //System.out.println("Current function is "+curr_fun+" and "+map);
         fun_env curr_env = map.get(curr_fun);
         curr_env.call=true;
         if(arg_no>curr_env.max_arg) {curr_env.max_arg=arg_no;};
         arg_no=0;
         return _ret;
      }
      else  {
         n.f0.accept(this, argu);
         String s_exp = (String)n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         args_flag = true;
         n.f3.accept(this, argu);
         args_flag = false;
         //System.out.println("CALL "+arguments.size()+" with args "+arguments);
         n.f4.accept(this, argu);
         caller_statement(s_exp, arguments);
         v0_flag = false;
         arguments.clear();
         return (R)"v0";
      }
      
   }

   /**
    * f0 -> "HALLOCATE"
    * f1 -> SimpleExp()
    */
   public R visit(HAllocate n, A argu) {
      R _ret=null;
      if(first_trav) {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
      }
      else {
         n.f0.accept(this, argu);
         String reg = (String)n.f1.accept(this, argu);
         String ret = "HALLOCATE "+reg;
         return (R)ret;
      }
      return _ret;
   }

   /**
    * f0 -> Operator()
    * f1 -> Temp()
    * f2 -> SimpleExp()
    */
   public R visit(BinOp n, A argu) {
      R _ret=null;
      if(first_trav) {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
      }
      else {
         String op = (String)n.f0.accept(this, argu);
         String reg1 = (String)n.f1.accept(this, argu);
         String reg2 = (String)n.f2.accept(this, argu);
         v0_flag = false;
         String ret = op+" "+reg1+" "+reg2;
         return (R)ret;
      }
      return _ret;
   }

   /**
    * f0 -> "LE"
    *       | "NE"
    *       | "PLUS"
    *       | "MINUS"
    *       | "TIMES"
    *       | "DIV"
    */
   public R visit(Operator n, A argu) {
      R _ret=null;
      if(first_trav) {
         n.f0.accept(this, argu);
      }
      else {
         _ret = n.f0.accept(this, argu);
      }
      return _ret;
   }

   /**
    * f0 -> Temp()
    *       | IntegerLiteral()
    *       | Label()
    */
   public R visit(SimpleExp n, A argu) {
      R _ret=null;
      if(first_trav) {
         n.f0.accept(this, argu);
      }
      else {
         _ret = n.f0.accept(this, argu);
      }
      return _ret;
   }

   /**
    * f0 -> "TEMP"
    * f1 -> IntegerLiteral()
    */
   public R visit(Temp n, A argu) {
      R _ret=null;
      if(first_trav) {
         arg_no++;
         String a = (String)n.f0.accept(this, argu);
         String b = (String)n.f1.accept(this, argu);
         String temp = a+" "+b;
         fun_env t = map.get(curr_fun);
         if(!t.temps.containsKey(temp)) {
            temp_info obj = new temp_info();
            obj.temp_name = temp;
            obj.st = obj.end = line_count;
            //System.out.println("Adding "+temp+" at "+line_count);
            t.temps.put(temp, obj);
         }
         else {
            temp_info obj = t.temps.get(temp);
            obj.end = line_count;
            //System.out.println(temp+" ending at "+line_count);
         }
         return _ret;
      }
      else {
         String a = (String)n.f0.accept(this, argu);
         want_int = true;
         String b = (String)n.f1.accept(this, argu);
         want_int = false;
         String temp = a+" "+b;
         if(want_temp) {return (R)temp;}
         if(args_flag) {arguments.add(temp);}
         String regis = get_temp(temp,map.get(curr_fun));
         return (R)regis;
      }
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n, A argu) {
      R _ret=null;
      if(first_trav) {
         _ret = n.f0.accept(this, argu);
         return _ret;   
      }
      else {
         String num = (String)n.f0.accept(this, argu);
         if(want_int) {return (R)num;}
         if(v0_flag) {
            System.out.println("MOVE v1 "+num);
            return (R)"v1";
         }
         else {
            System.out.println("MOVE v0 "+num);
            return (R)"v0";
         }
      }
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Label n, A argu) {
      R _ret=null;
      if(first_trav) {
         _ret = n.f0.accept(this, argu);
         if(label) {
            line_count++;
            String lab = (String)_ret;
            fun_env t = map.get(curr_fun);
            label_info tempor = new label_info();
            tempor.label_line = line_count;
            tempor.new_label = "L"+label_counter;
            //System.out.println(lab+" becomes "+tempor.new_label);
            label_counter++;
            t.labels.put(lab, tempor);
         }
         return _ret;   
      }
      else {
         _ret = n.f0.accept(this, argu);
         String s = (String)_ret;
         if(label) {
            System.out.println(map.get(curr_fun).labels.get(s).new_label);
            return null;
         }
         if(map.get(curr_fun).labels.containsKey(s)) {
            String labl = map.get(curr_fun).labels.get(s).new_label;
            //System.out.println("Contains "+s+" and returning "+labl);
            return (R)labl;
         }
         return _ret;
      }
   }

   public void back_edge(int a, int b) {
      //System.out.println("Back edge from "+b+" to "+a);
      fun_env envir = map.get(curr_fun);
      for (Map.Entry<String,temp_info> mapElement : envir.temps.entrySet()) {
         //String temp = mapElement.getKey();
         temp_info value = mapElement.getValue();
         if(value.end<b && value.end>a) {
            value.end = b;
            //System.out.println(temp+" updated to "+b);
         }
     }
   }

   public void fun_order() {
      for (Map.Entry<String,fun_env> func_pair : map.entrySet()) {
         System.out.println(func_pair.getKey());
      }
      System.out.println("_________________________________________");
      for(int i=0 ; i<cnt ; i++) {
         System.out.println(ordered_funs.get(i));
      }
   }
   public void reg_alloc() {
      for (int k=0 ; k<cnt ; k++) {
         fun_env func_env = ordered_funs.get(k);
         int arg_no = Integer.parseInt(func_env.args);
         func_env.stack_pointer=8;
         if(func_env.fun_name=="MAIN") {func_env.stack_pointer=0;}
         if(func_env.call) {func_env.stack_pointer+=10;}
         if(arg_no>4) {
            func_env.stack_pointer += (arg_no-4);
         }
         //System.out.println("Function "+func_env.fun_name);
         for(int i=0 ; i<func_env.temps.size() ; i++) {
            temp_info next_temp = new temp_info();
            int line_cnt = line_count;
            for (Map.Entry<String,temp_info> temp : func_env.temps.entrySet()) {
               //String temp_name = temp.getKey();
               //System.out.println("Going through "+temp.getKey());
               temp_info t = temp.getValue();
               if((!t. alloc) && line_cnt>t.st) {
                  next_temp = t;
                  line_cnt = t.st;
               }
            }
            if(line_cnt==line_count) {System.out.println("Temp not found"); System.exit(0); continue;}
            for (Map.Entry<String,Integer> reg : regs.entrySet()) {
               if(reg.getValue()<=next_temp.st) {
                  next_temp.reg = reg.getKey();
                  //System.out.println("Register "+next_temp.reg+" allocated to "+next_temp.temp_name);
                  regs.replace(reg.getKey(), next_temp.end);
                  next_temp.alloc = true;
                  break;
               }
            }
            if(!next_temp.alloc) {
               //System.out.println(next_temp.temp_name+" stacked at "+stack_count);
               next_temp.stack=true;
               next_temp.loc=""+func_env.stack_pointer;
               func_env.stack_pointer++;
               next_temp.alloc = true;
            }
         }
      }
   }

   public void init_args(int a, fun_env b) {
      //System.out.println("Initialising "+a+" args");
      for(int i=0 ; i<a ; i++) {
         temp_info k = new temp_info();
         k.st = k.end = line_count;
         k.temp_name = "TEMP "+i;
         b.temps.put(k.temp_name, k);
      }
   }

   public void caller_statement(String s_exp, Vector<String> vec) {
      //System.out.println("Current function "+curr_fun);
      //System.out.println(vec.size());
      fun_env obj = map.get(curr_fun);
      if(curr_fun=="MAIN") {
         for(int i=0 ; i<10 ; i++) {
            System.out.println("ASTORE SPILLEDARG "+i+" t"+i);
         }
      }
      else {
         for(int i=0 ; i<10 ; i++) {
            System.out.println("ASTORE SPILLEDARG "+(i+8)+" t"+i);
         }
      }
      if(vec.size()>4) {
         for(int i=0 ; i<4 ; i++) {
            String register = get_temp(vec.get(i), obj);
            System.out.println("MOVE a"+i+" "+register);
         }
         for(int i=0 ; i<vec.size()-4 ; i++) {
            String register = get_temp(vec.get(i+4), obj);
            System.out.println("PASSARG "+(i+1)+" "+register);
         }
      }
      else {
         for(int i=0 ; i<vec.size() ; i++) {
            String register = get_temp(vec.get(i), obj);
            System.out.println("MOVE a"+i+" "+register);
         }
      }
      System.out.println("CALL "+s_exp);
      if(curr_fun=="MAIN") {
         for(int i=0 ; i<10 ; i++) {
            System.out.println("ALOAD t"+i+" SPILLEDARG "+i);
         }
      }
      else {
         for(int i=0 ; i<10 ; i++) {
            System.out.println("ALOAD t"+i+" SPILLEDARG "+(i+8));
         }
      }
   }

   public String get_temp(String temp, fun_env envir) {
      // if(!envir.temps.containsKey(temp)) {
      //    System.out.println(temp+" doesn't exist in "+envir.fun_name); 
      //    System.exit(0);
      // }
      temp_info t = envir.temps.get(temp);
      if(t.stack) {
         if(v0_flag) {
            System.out.println("ALOAD v1 SPILLEDARG "+t.loc);
            return "v1";
         }
         // if(t.loc.equals("10")) {
         //    System.out.println("Temp is "+t.temp_name);
         // }
         System.out.println("ALOAD v0 SPILLEDARG "+t.loc);
         v0_flag = true;
         return "v0";
      }
      else
         return t.reg;
   }

   public void hload_statement(String temp, fun_env envir, String exp) {
      if(!envir.temps.containsKey(temp)) {
         System.out.println(temp+" is not there in "+envir.fun_name); 
         System.exit(0);
      }
      temp_info t = envir.temps.get(temp);
      if(t.stack) {
         if(v0_flag) {
            System.out.println("HLOAD v1 "+exp);
            System.out.println("ASTORE SPILLEDARG "+t.loc+" v1");
         }
         else {
            System.out.println("HLOAD v0 "+exp);
            System.out.println("ASTORE SPILLEDARG "+t.loc+" v0");
         }
      }
      else {
         System.out.println("HLOAD "+t.reg+" "+exp);
      }
   }

   public void move_statement(String temp, fun_env envir, String exp) {
      if(!envir.temps.containsKey(temp)) {
         System.out.println(temp+" is not there in "+envir.fun_name); 
         System.exit(0);
      }
      temp_info t = envir.temps.get(temp);
      if(t.stack) {
         if(v0_flag) {
            System.out.println("MOVE v1 "+exp);
            System.out.println("ASTORE SPILLEDARG "+t.loc+" v1");
         }
         else {
            System.out.println("MOVE v0 "+exp);
            System.out.println("ASTORE SPILLEDARG "+t.loc+" v0");
         }
      }
      else {
         System.out.println("MOVE "+t.reg+" "+exp);
      }
   }

   public void assign_args(int n, fun_env fe) {
      //System.out.println("Assigning Args");
      if(n>4) {
         for(int i=0 ; i<4 ; i++) {
            String temp_val = "TEMP "+i;
            move_statement(temp_val, fe, "a"+i);
            // String regg = get_temp(temp_val, fe);
            // System.out.println("MOVE "+regg+" a"+i);
         }
         for(int i=0 ; i<n-4 ; i++) {
            String temp_val = "TEMP "+(i+4);
            // String regg = get_temp(temp_val, fe);
            System.out.println("ALOAD v0 SPILLEDARG "+i);
            v0_flag = true;
            move_statement(temp_val, fe, "v0");
            v0_flag = false;
            // System.out.println("MOVE "+regg+" a"+i);
         }
      }
      else {
         for(int i=0 ; i<n ; i++) {
            String temp_val = "TEMP "+i;
            move_statement(temp_val, fe, "a"+i);
         }
      }
      //System.out.println("Assigning Args Done");
   }

   public void callee_store(fun_env obj) {
      int argg = Integer.parseInt(obj.args);
      int offset = argg-4;
      if(offset<0) {offset = 0;}
      for(int i=0 ; i<8 ; i++) {
         System.out.println("ASTORE SPILLEDARG "+(i+offset)+" s"+i);
      }
   }

   public void callee_load(fun_env obj) {
      int argg = Integer.parseInt(obj.args);
      int offset = argg-4;
      if(offset<0) {offset = 0;}
      for(int i=0 ; i<8 ; i++) {
         System.out.println("ALOAD s"+i+" SPILLEDARG "+(i+offset));
      }
   }
}
